What are the strengths and weaknesses of Python?
    - High-level, interprested
    - Readability
    - Large standard library/open-source community
    - Versatile features and fewer programming codes
    - Integration feature: with Java, C++

    - Weak in mobile computing
    - Low speed: Python executes with the help of an interpreter instead of the compiler, which causes it to slow down


Who is using Django?
    Pinterest, PBS, Instagram, Washington Times, Mozilla, etc.


Why do we need a virtual environtment?
    A virtual environtment allows you to have a virtual installation of Python and packages on your computer. Packages change and get updated often and there may be compatibility issues. Anything installed with pipenv or conda when the environment is activated, will only be installed for this environment. Therefore, a virtual environment helps you to specify and avoid confusion of versions of the packages that you use. If you update your packages on the local machine, you won't have to worry that the web app built in the virtual environemtn will be broken because of compatibility issues.


__init__.py:
    This file allows Django to know that the directory can be treated as a package.

settings.py:
    This is where you save all your project settings, including all the installed apps.

urls.py:
    This will save all the url patterns for your project.

wsgi.py:
    It is the "web server gateway interface". It will later help to deploy the app to production.

manage.py:
    This is associated with many command lines that we will use on the web app.
    <python manage.py runserver>
    <python manage.py migrate>
    <python manage.py startproject first_project>
    <python manage.py startapp first_app>


Migration:
    A migration allows you to move databases from one design to antoher. 


A Django Application:
    A Django application is created for a specific functionality of your web app, for example, a registration app, a polling app, a comments app, etc. These Django apps can then be plugged into other Django projects.

    With this structure, you can reuse your Django app among various Django projects, or you can use other poeple's Django apps in your Django projects.

admin.py:
    You can register your models here.

views.py:
    This is where you have functions that handle requests and return responses.


Templates:
    - You first need to create a templates directory, and then a subdirectory for each specific app's template. It looks like:
        <first_project/templates/first_app>
    - We can use Python's os module to dynamically generate the correct file path strings for DIR. It goes like this:
        BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        TEMPLATE_DIR = os.path.join(BASE_DIR, "templates")


Static Files:
    - Inside the root folder, create folder static/images
    - In settings.py, add <STATIC_DIR = os.path.join(BASE_DIR, "static")>
    - In the html page, add 
        {% load staticfiles %}
        <img src="{% static "images/django.jpg" %}" alt="django picture">
    - To link to a css file in html, add:
        <link rel="stylesheet" href="{% static "css/mystyle.css" %}">


Models:
    - Often models will reference each other. For this purpose, we use the concepts of Foreign Keys and Primary Keys. A primary key is a unique ID for each row in a table. A foreign key denotes that the the column coincides with a primary of another table.
    - Run the django command:
        <python manage.py migrate>
        <python manage.py makemigrations app_1>
        <python manage.py migrate>


Add To Model With Shell Commands:
    - <python manage.py shell>
    - from first_app.models import Topic
    - t = Topic(top_name="Social Network")
    - t.save()
    - print(Topic.object.all())


In admin.py:
    from django.contrib import admin
    from first_app.models import Topic, WebPage, AccessRecord

    admin.site.register(Topic)
    admin.site.register(WebPage)
    admin.site.register(AccessRecord)


To Create Superuser:
    <python manage.py createsuperuser>


Population Scripts:
    <pipenv install Faker>


To Query Models from view.py:
    from first_app.models import AccessRecord, Topic, WebPage

    def index(request):
        webpage_list = AccessRecord.objects.order_by('date')
        date_dict = {'access_records':webpage_list }
        
        return render(request, 'first_app/index.html', context='date_dict')

To render the context in index.html:
    {% load staticfiles}

    {% if access_records%}
    <table>
    <thead>
      <th>Site Name</th>
      <th>Date Accessed</th>
    </thead>

    {% for acc in access_records%}
    <tr>
      <td> {{acc.name}} </td>
      <td> {{acc.date}} </td>
    </tr>
    {% endfor %}

    </table>

    {% else %}
    <p>No Access Record Found.</p>

    {% endif %}


Create forms.py In App Folder:
    from django import forms

    classFormName(forms.Form):
        name = forms.CharField()
        email = forms.EmailField()
        text = forms.CharField(widget=forms.Textarea)


Add form_page.html:

    <form method="POST">
        {{ form.as_p }}
        {% csrf_token %}
        <input type="submit" value="Submit">
    </form>

    - <csrf_token> is a Cross-Site Request Forgery token, which secures the HTTP POST action that is initiated on the subsequent submission of a form.


Add Function In views.py:

    def form_name_view(request):
        form = forms.FormName()

        if request.method == 'POST':
            form = forms.FormName(request.POST)

            if form.is_valid():
                print('Form Validation Success.')

        return render(request, 'basicapp/form_page.html', {'form': form})









Source: https://medium.com/@mindfiresolutions.usa/advantages-and-disadvantages-of-python-programming-language-fd0b394f2121 

